#!/usr/bin/env python
import argparse
import re
from pathlib import Path
import shutil

from tqdm import tqdm

# Opening tag can be anywhere in the line, e.g.
#   <tbody_1>
#   ... <tbody_1.1> ...
TBODY_OPEN_RE = re.compile(r"<tbody_([0-9.]+)>", re.IGNORECASE)


def split_by_tbody(text: str):
    """
    Return (header, [tbody_block1, tbody_block2, ...]).

    - 'header' is everything before the first <tbody_…> tag.
    - Each tbody_block starts at its own <tbody_X> (inclusive) and
      ends at the matching </tbody_X> (inclusive). If the closing tag
      is missing, it goes up to the next <tbody_…> or EOF.

    If no tbody tag is found, returns (None, None).
    """
    matches = list(TBODY_OPEN_RE.finditer(text))
    if not matches:
        return None, None

    header = text[:matches[0].start()]
    blocks = []

    for i, m in enumerate(matches):
        tbody_id = m.group(1)  # e.g. "1", "1.1", "1.1.1"
        start = m.start()

        # matching closing tag: </tbody_1.1.1>
        close_pat = re.compile(r"</tbody_" + re.escape(tbody_id) + r">",
                               re.IGNORECASE)
        close_match = close_pat.search(text, m.end())

        if close_match:
            end = close_match.end()
        else:
            # no closing tag: go until next opening tag or EOF
            if i + 1 < len(matches):
                end = matches[i + 1].start()
            else:
                end = len(text)

        blocks.append(text[start:end])

    # Attach any trailing text after the last tbody block
    last_end = end
    if last_end < len(text):
        blocks[-1] += text[last_end:]

    return header, blocks


def process_file(src_path: Path, dst_dir: Path) -> None:
    """Process a single .txt file: split on tbody blocks or copy unchanged."""
    text = src_path.read_text(encoding="utf-8", errors="replace")

    header, blocks = split_by_tbody(text)

    # No tbody markers: copy unchanged
    if header is None or not blocks:
        dst_path = dst_dir / src_path.name
        shutil.copy2(src_path, dst_path)
        return

    # One output file per tbody block
    for i, block in enumerate(blocks, start=1):
        out_name = f"{src_path.stem}_part{i}{src_path.suffix}"
        out_path = dst_dir / out_name
        out_path.write_text(header + block, encoding="utf-8")


def main():
    parser = argparse.ArgumentParser(
        description="Split .txt files on <tbody_X>...</tbody_X> blocks "
                    "or copy unchanged."
    )
    parser.add_argument("input_dir", help="Folder containing .txt files")
    parser.add_argument("output_dir", help="Folder for output files")
    args = parser.parse_args()

    in_dir = Path(args.input_dir)
    out_dir = Path(args.output_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    txt_files = [p for p in in_dir.glob("*.txt") if p.is_file()]

    for src in tqdm(txt_files, desc="Processing .txt files"):
        process_file(src, out_dir)


if __name__ == "__main__":
    main()