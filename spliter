#!/usr/bin/env python
import argparse
import re
from pathlib import Path
import shutil

from tqdm import tqdm

# Opening tag can be anywhere in a line, e.g.
#   <tbody_1>
#   ... <tbody_1.1> ...
TBODY_OPEN_RE = re.compile(r"<tbody_([0-9.]+)>", re.IGNORECASE)


def split_by_tbody(text: str):
    """
    Return (header, [tbody_block1, tbody_block2, ...]).

    - 'header' is everything before the first <tbody_…> tag.
    - We detect ALL <tbody_X>…</tbody_X> ranges.
    - We then keep only the *leaf* ranges, i.e. those that do not
      contain another <tbody_…> start inside them.
    - Each returned block starts at its own <tbody_X> and ends at its
      own </tbody_X>, inclusive.

    If no tbody tag is found, returns (None, None).
    """
    open_matches = list(TBODY_OPEN_RE.finditer(text))
    if not open_matches:
        return None, None

    header = text[:open_matches[0].start()]

    # First, build all blocks (they may be nested / overlapping)
    blocks = []  # each: dict(id, start, end)
    for m in open_matches:
        tbody_id = m.group(1)          # e.g. "1", "1.1", "1.1.1"
        start = m.start()

        # Find matching closing tag: </tbody_X>
        close_pat = re.compile(r"</tbody_" + re.escape(tbody_id) + r">",
                               re.IGNORECASE)
        close_match = close_pat.search(text, m.end())
        if close_match:
            end = close_match.end()
        else:
            # If no closing tag is found, go to EOF
            end = len(text)

        blocks.append({"id": tbody_id, "start": start, "end": end})

    # Keep only leaf blocks (no other block starts inside them)
    leaf_blocks = []
    for i, b in enumerate(blocks):
        has_child = any(
            j != i and blocks[j]["start"] > b["start"] and blocks[j]["start"] < b["end"]
            for j in range(len(blocks))
        )
        if not has_child:
            leaf_blocks.append(b)

    # Sort by position in file
    leaf_blocks.sort(key=lambda b: b["start"])

    # Convert to text slices
    block_texts = [text[b["start"]:b["end"]] for b in leaf_blocks]

    return header, block_texts


def process_file(src_path: Path, dst_dir: Path) -> None:
    """Process a single .txt file: split on tbody blocks or copy unchanged."""
    text = src_path.read_text(encoding="utf-8", errors="replace")

    header, blocks = split_by_tbody(text)

    # No tbody markers: copy unchanged
    if header is None or not blocks:
        dst_path = dst_dir / src_path.name
        shutil.copy2(src_path, dst_path)
        return

    # One output file per tbody block
    for i, block in enumerate(blocks, start=1):
        out_name = f"{src_path.stem}_part{i}{src_path.suffix}"
        out_path = dst_dir / out_name
        out_path.write_text(header + block, encoding="utf-8")


def main():
    parser = argparse.ArgumentParser(
        description="Split .txt files so each output has exactly one "
                    "<tbody_X>...</tbody_X> block."
    )
    parser.add_argument("input_dir", help="Folder containing .txt files")
    parser.add_argument("output_dir", help="Folder for output files")
    args = parser.parse_args()

    in_dir = Path(args.input_dir)
    out_dir = Path(args.output_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    txt_files = [p for p in in_dir.glob("*.txt") if p.is_file()]

    for src in tqdm(txt_files, desc="Processing .txt files"):
        process_file(src, out_dir)


if __name__ == "__main__":
    main()